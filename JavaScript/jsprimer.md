とりいそぎ、先頭から読んでいって
知らなかったこと、気になった部分などを抜粋。
あとで、ちゃんとまとめる。。。かも。

ーーー

JavaScriptは大文字小文字を区別

文はセミコロン（;）によって区切られます。 特殊なルールにもとづき、セミコロンがない文も、行末に自動でセミコロンが挿入されるという仕組みも持っています。
しかし、暗黙的なものへ頼ると意図しない挙動が発生するため、セミコロンは常に書くようにします。

JavaScriptの実行コンテキストとして"Script"と"Module"があります。

"Module"の実行コンテキストでは、このstrict modeがデフォルト

"use strict"という文字列をファイルまたは関数の先頭に書くことで、そのスコープにあるコードはstrict modeで実行されます。

strict modeでは、evalやwithといったレガシーな機能や構文を禁止します

varなどのキーワードを含まずに変数を宣言しようとした場合に、strict modeでは例外が発生します。

常にstrict modeで実行できるコードを書くことが、より安全なコードにつながります。

constキーワードでは、再代入できない変数の宣言

変数同士を,（カンマ）で区切ることにより、同時に複数の変数を定義できます。

変数への再代入は「変数の値は最初に定義した値と常に同じである」という参照透過性と呼ばれるルールを壊すため、バグを発生させやすい要因として知られています。

letキーワードでは、値の再代入が可能な変数を宣言

letはconstとは異なり、初期値を指定しない変数も定義できます。 初期値が指定されなかった変数はデフォルト値としてundefinedという値で初期化されます。

varキーワードは同じ名前の変数を再定義できてしまう問題があります。

varには変数の巻き上げと呼ばれる意図しない挙動があります。

変数名の名前（識別子）には、次のルールがあります。

半角のアルファベット、_（アンダースコア）、$（ダラー）、数字を組み合わせた名前にする
変数名は数字から開始できない
予約語と被る名前は利用できない
→「$」が使えるのが特徴的かな。

constは定数ではない
constは「再代入できない変数」を定義する変数宣言であり、必ずしも定数を定義するわけではありません。
→プリミティブな値の場合は定数になるが、オブジェクトの場合、そのプロパティなどは変更可能

JavaScriptでは、文字列も一度作成したら変更できないイミュータブルの特性を持ち、プリミティブ型の一種として扱われます。

オブジェクトは、一度作成した後もその値自体を変更できるためミュータブル（mutable）の特性を持ちます。
オブジェクトは、値そのものではなく値への参照を経由して操作されるため、参照型のデータともいいます。
プリミティブ型でないものは、オブジェクト
typeof演算子を使うことで、次のようにデータ型を調べることができます。

0から始まる浮動小数点数は、0を省略して書くことができます。
しかし、JavaScriptでは.をオブジェクトにおいて利用する機会が多いため、 0から始まる場合でも省略せずに書いたほうが意図しない挙動を減らせるでしょう。

文字列リテラル
"（ダブルクオート）と'（シングルクオート）は全く同じ意味
ダブルクオートとシングルクオートどちらも、改行をそのままは入力できません。
改行の代わりに改行記号のエスケープシーケンス（\n）を使うことで複数行の文字列を書くことができます。
複数行の文字列も` で囲めば、そのまま書くことができます。
テンプレートリテラル内で${変数名}と書いた場合に、その変数の値を埋め込むことができます。

プリミティブ型として紹介したundefinedはリテラルではありません。
undefinedはただのグローバル変数で、undefinedという値を持っているだけ

objのkeyを参照するには、.（ドット）で繋ぎ参照する方法と、 []（ブラケット）で参照する方法があります。
ドット記法では、プロパティ名が変数名と同じく識別子である必要があります。

正規表現リテラルは/と/で正規表現のパターン文字列を囲みます。
正規表現のパターン内では、+や\（バックスラッシュ）から始まる特殊文字が特別な意味を持ちます。

明示的にラッパーオブジェクトを使うべき理由はありません。
なぜなら、JavaScriptではプリミティブ型のデータに対してもオブジェクトのように参照できる仕組みがあるため
プリミティブ型のデータのプロパティへアクセスする際に、対応するラッパーオブジェクトへ暗黙的に変換してからプロパティへアクセスするため
ラッパーオブジェクトを明示的に作成する必要はないため、常にリテラルでプリミティブ型のデータを表現することを推奨します。
プリミティブ型のデータであってもオブジェクトのようにプロパティ（メソッドなども含む）を参照できる

数値に変換できない文字列などはNaNという特殊な値へと変換されます。

NaNは"Not-a-Number"の略称で、数値ではないがNumber型の値を表現しています。 NaNはどの値とも（NaN自身に対しても）一致しない特性があり、Number.isNaNメソッドを使うことでNaNの判定を行えます。
単項プラス演算子は文字列から数値への変換に使うべきではありません。 なぜなら、Numberコンストラクタ関数やparseInt関数などの明示的な変換方法が存在するためです。

等価演算子（==）はオペランド同士が異なる型の値であった場合に、 同じ型となるように暗黙的な型変換してから比較します。
意図しない挙動となることがあるため、暗黙的な型変換が行われる等価演算子（==）を使うべきではありません。 代わりに、厳密等価演算子（===）を使い、異なる型を比較したい場合は明示的に型を合わせるべきです。

例外的に、等価演算子（==）が使われるケースとして、nullとundefinedの比較があります。

不等価演算子も、等価演算子（==）と同様に異なる型のオペランドを比較する際に、暗黙的な型変換をしてから比較します。
不等価演算子（!=）は、利用するべきではありません。 代わりに暗黙的な型変換をしない厳密不等価演算子（!==）を利用します。

ビット演算子はオペランドを符号付き32bit整数に変換してから演算します。 ビット演算子による演算結果は10進数の数値を返します。

文字列（Stringオブジェクト）にincludesメソッドが実装されました。 includesメソッドは指定した文字列が含まれているかを真偽値で返します。

左シフト演算子は、数値であるnumをbitの数だけ左へシフトします。 左にあふれたビットは破棄され、0のビットを右から詰めます。

右シフト演算子は、数値であるnumをbitの数だけ右へシフトします。 右にあふれたビットは破棄され、左端のビットのコピーを左から詰めます。

配列にはjoinメソッド、オブジェクトにはJSON.stringifyメソッドなどより適切な方法があります。 そのため、Stringコンストラクタ関数での変換は、あくまでプリミティブ型に対してのみに留めるべきです。

Numberコンストラクタ関数、Number.parseInt、Number.parseFloatは、 数字以外の文字列を渡すとNaN（Not a Number）を返します。

return文の返り値を省略した場合は、未定義の値であるundefinedを返します。
関数が何も値を返す必要がない場合は、return文そのものを省略できます。 return文そのものを省略した場合は、undefinedという値を返します。

JavaScriptでは、関数の定義した仮引数の個数と実際に呼び出し時の引数の個数が違っても、関数を呼び出せます。
定義した関数の仮引数よりも呼び出し時の引数が少ない場合、余った仮引数にはundefinedという値が代入されます。
関数の仮引数に対して引数の個数が多い場合、溢れた引数は単純に無視されます。

Rest parametersが利用できる環境では、arguments変数を使うべき理由はありません。
（関数が可変長引数を受け付けるのかを仮引数だけを見て判断できない）

関数宣言で定義した関数は、関数の名前でのみ区別されます。 そのため、同じ名前の関数を複数回宣言した場合には、後ろで宣言された関数によって上書きされます。

Arrow Functionについては次のような特徴があります。
　thisが静的に決定する（詳細は「関数とスコープ」の章で解説します）
　arguments変数を参照できない

Arrow Functionで問題ない場合はArrow Functionで書き、そうでない場合はfunctionキーワードを使うことを推奨

引数として渡される関数のことをコールバック関数と呼びます。 一方、コールバック関数を引数として使う関数やメソッドのことを高階関数と呼びます。

オブジェクトのプロパティである関数をメソッドとよびます
JavaScriptにおいて、関数とメソッドの機能的な違いはありません。 しかし、呼び方を区別したほうがわかりやすいため、ここではオブジェクトのプロパティである関数をメソッドと呼びます。

ES2015からは、メソッドとしてプロパティを定義するための短縮した書き方が追加されています。
次のように、オブジェクトリテラルの中で メソッド名(){ /*メソッドの処理*/ } と書くことができます。
メソッドを定義する場合は、できるだけこの短縮記法に統一した方がよいでしょう。

ーーー
「関数と宣言」まで読了。次、「分と式」
https://jsprimer.net/basic/statement-expression/


